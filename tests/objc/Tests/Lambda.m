//
//  Lambda
//  Tests
//
//  Source generated by Haxe Objective-C target
//

#import "Lambda.h"

@implementation Lambda

+ (NSMutableArray*) array:(id)it{
	
	NSMutableArray *a = (NSMutableArray*)[[NSMutableArray alloc] init];
	{
		id _it = FAnon[it iterator];
		while ( [_it hasNext] ) do {
			id i = [_it next];
			[a push:i];
		}
	}
	return a;
}
+ (List*) list:(id)it{
	
	List *l = [[List alloc] init];
	{
		id _it = FAnon[it iterator];
		while ( [_it hasNext] ) do {
			id i = [_it next];
			[l add:i];
		}
	}
	return l;
}
+ (List*) map:(id)it f:(SEL)f{
	
	List *l = [[List alloc] init];
	{
		id _it = FAnon[it iterator];
		while ( [_it hasNext] ) do {
			id x = [_it next];
			[l add:[f:x]];
		}
	}
	return l;
}
+ (List*) mapi:(id)it f:(SEL)f{
	
	List *l = [[List alloc] init];
	int i = 0;
	{
		id _it = FAnon[it iterator];
		while ( [_it hasNext] ) do {
			id x = [_it next];
			[l add:[f:i++ :x]];
		}
	}
	return l;
}
+ (BOOL) has:(id)it elt:(id)elt cmp:(SEL)cmp{
	// Simulated optional arguments
	if (cmp == nil) cmp = nil;
	
	if (cmp == nil) {
		{
			id _it = FAnon[it iterator];
			while ( [_it hasNext] ) do {
				id x = [_it next];
				if (x == elt) return YES;
			}
		}
	}
	else {
		{
			id _it2 = FAnon[it iterator];
			while ( [_it2 hasNext] ) do {
				id x = [_it2 next];
				if ([cmp:x :elt]) return YES;
			}
		}
	}
	return NO;
}
+ (BOOL) exists:(id)it f:(SEL)f{
	{
		id _it = FAnon[it iterator];
		while ( [_it hasNext] ) do {
			id x = [_it next];
			if ([f:x]) return YES;
		}
	}
	return NO;
}
+ (BOOL) foreach:(id)it f:(SEL)f{
	{
		id _it = FAnon[it iterator];
		while ( [_it hasNext] ) do {
			id x = [_it next];
			if (![f:x]) return NO;
		}
	}
	return YES;
}
+ (void) iter:(id)it f:(SEL)f{
	{
		id _it = FAnon[it iterator];
		while ( [_it hasNext] ) do {
			id x = [_it next];
			[f:x];
		}
	}
}
+ (List*) filter:(id)it f:(SEL)f{
	
	List *l = [[List alloc] init];
	{
		id _it = FAnon[it iterator];
		while ( [_it hasNext] ) do {
			id x = [_it next];
			if ([f:x]) [l add:x];
		}
	}
	return l;
}
+ (id) fold:(id)it f:(SEL)f first:(id)first{
	{
		id _it = FAnon[it iterator];
		while ( [_it hasNext] ) do {
			id x = [_it next];
			first = [f:x :first];
		}
	}
	return first;
}
+ (int) count:(id)it pred:(SEL)pred{
	// Simulated optional arguments
	if (pred == nil) pred = nil;
	
	int n = 0;
	if (pred == nil) {
		{
			id _it = FAnon[it iterator];
			while ( [_it hasNext] ) do {
				id _ = [_it next];
				n++;
			}
		}
	}
	else {
		{
			id _it2 = FAnon[it iterator];
			while ( [_it2 hasNext] ) do {
				id x = [_it2 next];
				if ([pred:x]) n++;
			}
		}
	}
	return n;
}
+ (BOOL) empty:(id)it{
	return !FAnon[FAnon[it iterator] hasNext];
}
+ (int) indexOf:(id)it v:(id)v{
	int i = 0;
	{
		id _it = FAnon[it iterator];
		while ( [_it hasNext] ) do {
			id v2 = [_it next];
			{
				if (v == v2) return i;
				i++;
			};
		}
	}
	return -1;
}
+ (List*) concat:(id)a b:(id)b{
	
	List *l = [[List alloc] init];
	{
		id _it = FAnon[a iterator];
		while ( [_it hasNext] ) do {
			id x = [_it next];
			[l add:x];
		}
	}
	{
		id _it2 = FAnon[b iterator];
		while ( [_it2 hasNext] ) do {
			id x = [_it2 next];
			[l add:x];
		}
	}
	return l;
}

@end
