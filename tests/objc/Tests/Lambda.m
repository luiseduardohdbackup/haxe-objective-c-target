//
//  Lambda
//  Tests
//
//  Source generated by Haxe Objective-C target
//

#import "Lambda.h"

@implementation Lambda

+ (NSMutableArray*) array:(id)it{
	
	NSMutableArray *a = [[NSMutableArray alloc] init];
	{
		{ var $it : * = [it iterator]
		for ( $it.hasNext() ) { var i : id = $it.next()
		[a push:i]
	}
	return a;
}
+ (List*) list:(id)it{
	
	List *l = [[List alloc] init];
	{
		{ var $it : * = [it iterator]
		for ( $it.hasNext() ) { var i : id = $it.next()
		[l add:i]
	}
	return l;
}
+ (List*) map:(id)it f:(SEL*)f{
	
	List *l = [[List alloc] init];
	{
		{ var $it : * = [it iterator]
		for ( $it.hasNext() ) { var x : id = $it.next()
		[l add:[f:x]]
	}
	return l;
}
+ (List*) mapi:(id)it f:(SEL*)f{
	
	List *l = [[List alloc] init];
	int i = 0;
	{
		{ var $it : * = [it iterator]
		for ( $it.hasNext() ) { var x : id = $it.next()
		[l add:[f:i++ :x]]
	}
	return l;
}
+ (BOOL) has:(id)it elt:(id)elt cmp:(SEL*)cmp{
	if (cmp==nil) cmp=nil;
	if (cmp == nil) {
		{
			{ var $it : * = [it iterator]
			for ( $it.hasNext() ) { var x : id = $it.next()
			if (x == elt) return YES
		}
	}
	else {
		{
			{ var $it2 : * = [it iterator]
			for ( $it2.hasNext() ) { var x : id = $it2.next()
			if ([cmp:x :elt]) return YES
		}
	}
	return NO;
}
+ (BOOL) exists:(id)it f:(SEL*)f{
	{
		{ var $it : * = [it iterator]
		for ( $it.hasNext() ) { var x : id = $it.next()
		if ([f:x]) return YES
	}
	return NO;
}
+ (BOOL) foreach:(id)it f:(SEL*)f{
	{
		{ var $it : * = [it iterator]
		for ( $it.hasNext() ) { var x : id = $it.next()
		if (![f:x]) return NO
	}
	return YES;
}
+ (void) iter:(id)it f:(SEL*)f{
	{
		{ var $it : * = [it iterator]
		for ( $it.hasNext() ) { var x : id = $it.next()
		[f:x]
	}
}
+ (List*) filter:(id)it f:(SEL*)f{
	
	List *l = [[List alloc] init];
	{
		{ var $it : * = [it iterator]
		for ( $it.hasNext() ) { var x : id = $it.next()
		if ([f:x]) [l add:x]
	}
	return l;
}
+ (id) fold:(id)it f:(SEL*)f first:(id)first{
	{
		{ var $it : * = [it iterator]
		for ( $it.hasNext() ) { var x : id = $it.next()
		first = [f:x :first]
	}
	return first;
}
+ (int) count:(id)it pred:(SEL*)pred{
	if (pred==nil) pred=nil;
	int n = 0;
	if (pred == nil) {
		{
			{ var $it : * = [it iterator]
			for ( $it.hasNext() ) { var _ : id = $it.next()
			n++
		}
	}
	else {
		{
			{ var $it2 : * = [it iterator]
			for ( $it2.hasNext() ) { var x : id = $it2.next()
			if ([pred:x]) n++
		}
	}
	return n;
}
+ (BOOL) empty:(id)it{
	return ![[it iterator] hasNext];
}
+ (int) indexOf:(id)it v:(id)v{
	int i = 0;
	{
		{ var $it : * = [it iterator]
		for ( $it.hasNext() ) { var v2 : id = $it.next()
		{
			if (v == v2) return i;
			i++;
		}
	}
	return -1;
}
+ (List*) concat:(id)a b:(id)b{
	
	List *l = [[List alloc] init];
	{
		{ var $it : * = [a iterator]
		for ( $it.hasNext() ) { var x : id = $it.next()
		[l add:x]
	}
	{
		{ var $it2 : * = [b iterator]
		for ( $it2.hasNext() ) { var x : id = $it2.next()
		[l add:x]
	}
	return l;
}

@end
