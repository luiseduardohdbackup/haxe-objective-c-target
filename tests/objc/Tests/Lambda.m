//
//  Lambda
//  Tests
//
//  Source generated by Haxe Objective-C target
//

#import "Lambda.h"

@implementation Lambda

NSMutableArray*(^block_array)(id it) = ^(id it) { [me array:it]; };
+ (NSMutableArray*) array:(id)it{
	
	NSMutableArray *a = (NSMutableArray*)[[NSMutableArray alloc] init];
	{
		id _it = [it iterator];
		while ( [_it hasNext] ) do {
			id i = [_it next];
			[a push:i];
		}
	}
	return a;
}
List*(^block_list)(id it) = ^(id it) { [me list:it]; };
+ (List*) list:(id)it{
	
	List *l = [[List alloc] init];
	{
		id _it = [it iterator];
		while ( [_it hasNext] ) do {
			id i = [_it next];
			[l add:i];
		}
	}
	return l;
}
List*(^block_map)(id it, SEL f) = ^(id it, SEL f) { [me map:it f:f]; };
+ (List*) map:(id)it f:(SEL)f{
	
	List *l = [[List alloc] init];
	{
		id _it = [it iterator];
		while ( [_it hasNext] ) do {
			id x = [_it next];
			[l add:[f:x]];
		}
	}
	return l;
}
List*(^block_mapi)(id it, SEL f) = ^(id it, SEL f) { [me mapi:it f:f]; };
+ (List*) mapi:(id)it f:(SEL)f{
	
	List *l = [[List alloc] init];
	int i = 0;
	{
		id _it = [it iterator];
		while ( [_it hasNext] ) do {
			id x = [_it next];
			[l add:[f:i++ :x]];
		}
	}
	return l;
}
BOOL(^block_has)(id it, id elt, SEL cmp) = ^(id it, id elt, SEL cmp) { [me has:it elt:elt cmp:cmp]; };
+ (BOOL) has:(id)it elt:(id)elt cmp:(SEL)cmp{
	// Simulated optional arguments
	if (cmp == nil) cmp = nil;
	
	if (cmp == nil) {
		{
			id _it = [it iterator];
			while ( [_it hasNext] ) do {
				id x = [_it next];
				if (x == elt) return YES;
			}
		}
	}
	else {
		{
			id _it2 = [it iterator];
			while ( [_it2 hasNext] ) do {
				id x = [_it2 next];
				if ([cmp:x :elt]) return YES;
			}
		}
	}
	return NO;
}
BOOL(^block_exists)(id it, SEL f) = ^(id it, SEL f) { [me exists:it f:f]; };
+ (BOOL) exists:(id)it f:(SEL)f{
	{
		id _it = [it iterator];
		while ( [_it hasNext] ) do {
			id x = [_it next];
			if ([f:x]) return YES;
		}
	}
	return NO;
}
BOOL(^block_foreach)(id it, SEL f) = ^(id it, SEL f) { [me foreach:it f:f]; };
+ (BOOL) foreach:(id)it f:(SEL)f{
	{
		id _it = [it iterator];
		while ( [_it hasNext] ) do {
			id x = [_it next];
			if (![f:x]) return NO;
		}
	}
	return YES;
}
void(^block_iter)(id it, SEL f) = ^(id it, SEL f) { [me iter:it f:f]; };
+ (void) iter:(id)it f:(SEL)f{
	{
		id _it = [it iterator];
		while ( [_it hasNext] ) do {
			id x = [_it next];
			[f:x];
		}
	}
}
List*(^block_filter)(id it, SEL f) = ^(id it, SEL f) { [me filter:it f:f]; };
+ (List*) filter:(id)it f:(SEL)f{
	
	List *l = [[List alloc] init];
	{
		id _it = [it iterator];
		while ( [_it hasNext] ) do {
			id x = [_it next];
			if ([f:x]) [l add:x];
		}
	}
	return l;
}
id(^block_fold)(id it, SEL f, id first) = ^(id it, SEL f, id first) { [me fold:it f:f first:first]; };
+ (id) fold:(id)it f:(SEL)f first:(id)first{
	{
		id _it = [it iterator];
		while ( [_it hasNext] ) do {
			id x = [_it next];
			first = [f:x :first];
		}
	}
	return first;
}
int(^block_count)(id it, SEL pred) = ^(id it, SEL pred) { [me count:it pred:pred]; };
+ (int) count:(id)it pred:(SEL)pred{
	// Simulated optional arguments
	if (pred == nil) pred = nil;
	
	int n = 0;
	if (pred == nil) {
		{
			id _it = [it iterator];
			while ( [_it hasNext] ) do {
				id _ = [_it next];
				n++;
			}
		}
	}
	else {
		{
			id _it2 = [it iterator];
			while ( [_it2 hasNext] ) do {
				id x = [_it2 next];
				if ([pred:x]) n++;
			}
		}
	}
	return n;
}
BOOL(^block_empty)(id it) = ^(id it) { [me empty:it]; };
+ (BOOL) empty:(id)it{
	return ![[it iterator] hasNext];
}
int(^block_indexOf)(id it, id v) = ^(id it, id v) { [me indexOf:it v:v]; };
+ (int) indexOf:(id)it v:(id)v{
	int i = 0;
	{
		id _it = [it iterator];
		while ( [_it hasNext] ) do {
			id v2 = [_it next];
			{
				if (v == v2) return i;
				i++;
			};
		}
	}
	return -1;
}
List*(^block_concat)(id a, id b) = ^(id a, id b) { [me concat:a b:b]; };
+ (List*) concat:(id)a b:(id)b{
	
	List *l = [[List alloc] init];
	{
		id _it = [a iterator];
		while ( [_it hasNext] ) do {
			id x = [_it next];
			[l add:x];
		}
	}
	{
		id _it2 = [b iterator];
		while ( [_it2 hasNext] ) do {
			id x = [_it2 next];
			[l add:x];
		}
	}
	return l;
}

@end
