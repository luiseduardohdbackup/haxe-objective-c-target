//
//  Input
//  Tests
//
//  Source generated by Haxe Objective-C target
//

#import "Input.h"

@implementation Input


int(^block_readByte)() = ^() { [me readByte]; };
- (int) readByte{
	return ((int)($this:(snd ctx.path)) @throw (NSMutableString*)@"Not implemented";
	return __r__{
		
		int* __r__}
	}(self));
}
int(^block_readBytes)(Bytes *s, int pos, int len) = ^(Bytes *s, int pos, int len) { [me readBytes:s pos:pos len:len]; };
- (int) readBytes:(Bytes*)s pos:(int)pos len:(int)len{
	int k = len;
	
	NSMutableArray *b = (NSMutableArray*)s.b;
	if (pos < 0 || len < 0 || pos + len > block_length) @throw Error OutsideBounds;;
	while (k > 0) {
		[b objectAtIndex:pos] = (int)[block_readByte];
		pos++;
		k--;
	}
	return len;
}
void(^block_close)() = ^() { [me close]; };
- (void) close{
}
BOOL(^block_set_bigEndian)(BOOL b) = ^(BOOL b) { [me set_bigEndian:b]; };
- (BOOL) set_bigEndian:(BOOL)b{
	self.bigEndian = b;
	return b;
}
Bytes*(^block_readAll)(int bufsize) = ^(int bufsize) { [me readAll:bufsize]; };
- (Bytes*) readAll:(int)bufsize{
	// Simulated optional arguments
	if (bufsize == nil) bufsize = nil;
	
	if (bufsize == nil) bufsize = 16384;
	
	Bytes *buf = [Bytes alloc:bufsize];
	
	BytesBuffer *total = [[BytesBuffer alloc] init];
	@try {
		while (YES) {
			int len = [self readBytes:buf pos:0 len:bufsize];
			if (len == 0) @throw Error Blocked;;
			if (len < 0 || len > block_length) @throw Error OutsideBounds;;
		}
	}
	@catch (NSException *e) {
	}
	return [total getBytes];
}
void(^block_readFullBytes)(Bytes *s, int pos, int len) = ^(Bytes *s, int pos, int len) { [me readFullBytes:s pos:pos len:len]; };
- (void) readFullBytes:(Bytes*)s pos:(int)pos len:(int)len{
	while (len > 0) {
		int k = [self readBytes:s pos:pos len:len];
		pos += k;
		len -= k;
	}
}
Bytes*(^block_read)(int nbytes) = ^(int nbytes) { [me read:nbytes]; };
- (Bytes*) read:(int)nbytes{
	
	Bytes *s = [Bytes alloc:nbytes];
	int p = 0;
	while (nbytes > 0) {
		int k = [self readBytes:s pos:p len:nbytes];
		if (k == 0) @throw Error Blocked;;
		p += k;
		nbytes -= k;
	}
	return s;
}
NSMutableString*(^block_readUntil)(int end) = ^(int end) { [me readUntil:end]; };
- (NSMutableString*) readUntil:(int)end{
	
	StringBuf *buf = [[StringBuf alloc] init];
	int last;
	while ( (last = [block_readByte]) != end) buf.b += [block_fromCharCode:last];
	return buf.b;
}
NSMutableString*(^block_readLine)() = ^() { [me readLine]; };
- (NSMutableString*) readLine{
	
	StringBuf *buf = [[StringBuf alloc] init];
	int last;
	
	NSMutableString *s;
	@try {
		while ( (last = [block_readByte]) != 10) buf.b += [block_fromCharCode:last];
		s = block_b;
		if ([s characterAtIndex:s.length - 1] == 13) s = [block_substr:0 len:-1];
	}
	@catch (NSException *e) {
		s = block_b;
		if (s.length == 0) @throw e;;
	}
	return s;
}
float(^block_readFloat)() = ^() { [me readFloat]; };
- (float) readFloat{
	
	NSMutableArray *bytes = [[NSMutableArray alloc] initWithObjects:, nil];
	[bytes push:(int)[self readByte]];
	[bytes push:(int)[self readByte]];
	[bytes push:(int)[self readByte]];
	[bytes push:(int)[self readByte]];
	if (self.bigEndian) [bytes reverse];
	int sign = 1 -  ([bytes objectAtIndex:0] >> 7 << 1);
	int exp =  (([bytes objectAtIndex:0] << 1 & 255) | [bytes objectAtIndex:1] >> 7) - 127;
	int sig = ( ([bytes objectAtIndex:1] & 127) << 16 | [bytes objectAtIndex:2] << 8) | [bytes objectAtIndex:3];
	if (sig == 0 && exp == -127) return 0.0;
	return sign *  (1 + block_pow(2, -23) * sig) * block_pow(2, exp);
}
float(^block_readDouble)() = ^() { [me readDouble]; };
- (float) readDouble{
	return ((float)($this:(snd ctx.path)) @throw (NSMutableString*)@"not implemented";
	return __r__{
		
		float* __r__}
	}(self));
}
int(^block_readInt8)() = ^() { [me readInt8]; };
- (int) readInt8{
	int n = [self readByte];
	if (n >= 128) return n - 256;
	return n;
}
int(^block_readInt16)() = ^() { [me readInt16]; };
- (int) readInt16{
	int ch1 = [self readByte];
	int ch2 = [self readByte];
	int n = ( (self.bigEndian) ? ch2 | ch1 << 8 : ch1 | ch2 << 8);
	if ( (n & 32768) != 0) return n - 65536;
	return n;
}
int(^block_readUInt16)() = ^() { [me readUInt16]; };
- (int) readUInt16{
	int ch1 = [self readByte];
	int ch2 = [self readByte];
	return ( (self.bigEndian) ? ch2 | ch1 << 8 : ch1 | ch2 << 8);
}
int(^block_readInt24)() = ^() { [me readInt24]; };
- (int) readInt24{
	int ch1 = [self readByte];
	int ch2 = [self readByte];
	int ch3 = [self readByte];
	int n = ( (self.bigEndian) ? (ch3 | ch2 << 8) | ch1 << 16 : (ch1 | ch2 << 8) | ch3 << 16);
	if ( (n & 8388608) != 0) return n - 16777216;
	return n;
}
int(^block_readUInt24)() = ^() { [me readUInt24]; };
- (int) readUInt24{
	int ch1 = [self readByte];
	int ch2 = [self readByte];
	int ch3 = [self readByte];
	return ( (self.bigEndian) ? (ch3 | ch2 << 8) | ch1 << 16 : (ch1 | ch2 << 8) | ch3 << 16);
}
int(^block_readInt31)() = ^() { [me readInt31]; };
- (int) readInt31{
	int ch1; int ch2; int ch3; int ch4;
	if (self.bigEndian) {
		ch4 = [block_readByte];
		ch3 = [block_readByte];
		ch2 = [block_readByte];
		ch1 = [block_readByte];
	}
	else {
		ch1 = [block_readByte];
		ch2 = [block_readByte];
		ch3 = [block_readByte];
		ch4 = [block_readByte];
	}
	if ( (ch4 & 128) == 0 !=  ( (ch4 & 64) == 0)) @throw Error Overflow;;
	return ((ch1 | ch2 << 8) | ch3 << 16) | ch4 << 24;
}
int(^block_readUInt30)() = ^() { [me readUInt30]; };
- (int) readUInt30{
	int ch1 = [self readByte];
	int ch2 = [self readByte];
	int ch3 = [self readByte];
	int ch4 = [self readByte];
	if ( (( (self.bigEndian) ? ch1 : ch4)) >= 64) @throw Error Overflow;;
	return ( (self.bigEndian) ? ((ch4 | ch3 << 8) | ch2 << 16) | ch1 << 24 : ((ch1 | ch2 << 8) | ch3 << 16) | ch4 << 24);
}
CppInt32__*(^block_readInt32)() = ^() { [me readInt32]; };
- (CppInt32__*) readInt32{
	int ch1 = [self readByte];
	int ch2 = [self readByte];
	int ch3 = [self readByte];
	int ch4 = [self readByte];
	return ( (self.bigEndian) ? [CppInt32__ make:ch1 << 8 | ch2 b:ch3 << 8 | ch4] : [CppInt32__ make:ch4 << 8 | ch3 b:ch2 << 8 | ch1]);
}
NSMutableString*(^block_readString)(int len) = ^(int len) { [me readString:len]; };
- (NSMutableString*) readString:(int)len{
	
	Bytes *b = [Bytes alloc:len];
	[self readFullBytes:b pos:0 len:len];
	return [b toString];
}

@end
