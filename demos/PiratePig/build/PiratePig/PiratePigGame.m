//
//  PiratePigGame
//  PiratePig
//
//  Source generated by Haxe Objective-C target
//

#import "PiratePigGame.h"

@implementation PiratePigGame

+ (int) NUM_COLUMNS:(int)val {
	static int _val;
	if (val == nil) { if (_val == nil) _val = 8; }
	else { if (_val != nil) _val = val; }
	return _val;
}
+ (int) NUM_ROWS:(int)val {
	static int _val;
	if (val == nil) { if (_val == nil) _val = 8; }
	else { if (_val != nil) _val = val; }
	return _val;
}
+ (NSMutableArray*) tileImages:(NSMutableArray*)val {
	static NSMutableArray *_val;
	if (val == nil) { if (_val == nil) _val = [[NSMutableArray alloc] initWithObjects:(NSMutableString*)@"game_bear.png", (NSMutableString*)@"game_bunny_02.png", (NSMutableString*)@"game_carrot.png", (NSMutableString*)@"game_lemon.png", (NSMutableString*)@"game_panda.png", (NSMutableString*)@"game_piratePig.png", nil]; }
	else { if (_val != nil) _val = val; }
	return _val;
}
@synthesize Background;
@synthesize Logo;
@synthesize Score;
@synthesize TileContainer;
@synthesize currentScale;
@synthesize currentScore;
@synthesize cacheMouse;
@synthesize needToCheckMatches;
@synthesize selectedTile;
@synthesize tiles;
@synthesize usedTiles;
- (void) addTile:(int)row column:(int)column animate:(BOOL)animate{
	// Simulated optional arguments
	if (animate == nil) animate = YES;
	
	
	Tile *tile = nil;
	int type = roundf(rand() *  (PiratePigGame.tileImages length - 1))];
	{
		int _g = 0; 
		NSMutableArray *_g1 = (NSMutableArray*)self.usedTiles;
		while (_g < _g1.length) {
			
			Tile *usedTile = [_g1 objectAtIndex:_g];
			++_g;
			if (usedTile.removed && usedTile.superview == nil && usedTile.type == type) tile = usedTile;
		}
	}
	if (tile == nil) tile = [[Tile alloc] init:[[PiratePigGame tileImages:nil] objectAtIndex:type]];
	[tile initialize];
	tile.type = type;
	tile.row = row;
	tile.column = column;
	[[[self.tiles objectAtIndex:row] objectAtIndex:column] addObject: tile];
	CGPoint position = [self getPosition:row column:column];
	if (animate) {
		CGPoint firstPosition = [self getPosition:-1 column:column];
		tile.alpha = 0;
		CGRect rect = tile.frame;
		rect.origin.x = firstPosition.x;
		rect.origin.y = firstPosition.y;
		tile.frame = rect;
		[tile moveTo:0.15 *  (row + 1) targetX:position x targetY:position y];
	}
	else {
		CGRect rect = tile.frame;
		rect.origin.x = position.x;
		rect.origin.y = position.y;
		tile.frame = rect;
	}
	[self.TileContainer addSubview:tile];
	self.needToCheckMatches = YES;
}
- (void) construct{
	[self addSubview:self.Logo];
	int contentWidth = 75 * PiratePigGame.NUM_COLUMNS;
	CGRect rect = self.Score.frame;
	rect.origin.x = contentWidth - 200;
	rect.origin.y = 12;
	rect.size.width = 200;
	self.Score.frame = rect;
	[self addSubview:self.Score];
	[self addSubview:self.Background];
	CGRect rect1 = self.TileContainer.frame;
	rect1.origin.x = 14;
	rect1.origin.y = 99;
	self.TileContainer.frame = rect1;
	[self addSubview:self.TileContainer];
}
- (void) dropTiles{
	int _g1 = 0; int _g = PiratePigGame.NUM_COLUMNS;
	while (_g1 < _g) {
		int column = _g1++;
		int spaces = 0;
		{
			int _g3 = 0; int _g2 = PiratePigGame.NUM_ROWS;
			while (_g3 < _g2) {
				int row = _g3++;
				int index = PiratePigGame.NUM_ROWS - 1 - row;
				
				Tile *tile = [[self.tiles objectAtIndex:index] objectAtIndex:column];
				if (tile == nil) spaces++;
				else if (spaces > 0) {
					CGPoint position = [self getPosition:index + spaces column:column];
					[tile moveTo:0.15 * spaces targetX:position x targetY:position y];
					tile.row = index + spaces;
					[[self.tiles objectAtIndex:index + spaces] objectAtIndex:column] = tile;
					[[self.tiles objectAtIndex:index] objectAtIndex:column] = nil;
					self.needToCheckMatches = YES;
				}
			}
		}
		{
			int _g2 = 0;
			while (_g2 < (int)spaces) {
				int i = _g2++;
				int row = spaces - 1 - i;
				[self addTile:row column:column animate:nil];
			}
		}
	}
}
- (NSMutableArray*) findMatches:(BOOL)byRow accumulateScore:(BOOL)accumulateScore{
	// Simulated optional arguments
	if (accumulateScore == nil) accumulateScore = YES;
	
	
	NSMutableArray *matchedTiles = (NSMutableArray*)[[NSMutableArray alloc] init];
	int max;
	int secondMax;
	if (byRow) {
		max = PiratePigGame.NUM_ROWS;
		secondMax = PiratePigGame.NUM_COLUMNS;
	}
	else {
		max = PiratePigGame.NUM_COLUMNS;
		secondMax = PiratePigGame.NUM_ROWS;
	}
	{
		int _g = 0;
		while (_g < max) {
			int index = _g++;
			int matches = 0;
			
			NSMutableArray *foundTiles = (NSMutableArray*)[[NSMutableArray alloc] init];
			int previousType = -1;
			{
				int _g1 = 0;
				while (_g1 < secondMax) {
					int secondIndex = _g1++;
					
					Tile *tile;
					if (byRow) tile = [[self.tiles objectAtIndex:index] objectAtIndex:secondIndex];
					else tile = [[self.tiles objectAtIndex:secondIndex] objectAtIndex:index];
					if (tile != nil && !tile.moving) {
						if (previousType == -1) {
							previousType = tile.type;
							[foundTiles push:tile];
							continue;
						}
						else if (tile.type == previousType) {
							[foundTiles push:tile];
							matches++;
						}
					}
					if (tile == nil || tile.moving || tile.type != previousType || secondIndex == secondMax - 1) {
						if (matches >= 2 && previousType != -1) {
							if (accumulateScore) self.currentScore += [Std _int:powf(matches, 2) * 50];
							matchedTiles = [matchedTiles concat:foundTiles];
						}
						matches = 0;
						foundTiles = [[NSMutableArray alloc] init];
						if (tile == nil || tile.moving) {
							self.needToCheckMatches = YES;
							previousType = -1;
						}
						else {
							previousType = tile.type;
							[foundTiles push:tile];
						}
					}
				}
			}
		}
	}
	return matchedTiles;
}
- (CGPoint) getPosition:(int)row column:(int)column{
	return  CGPointMake(column * 73, row * 73);
}
- (void) initialize{
	self.currentScale = 1;
	self.currentScore = 0;
	self.tiles = [[NSMutableArray alloc] init];
	self.usedTiles = [[NSMutableArray alloc] init];
	{
		int _g1 = 0; int _g = PiratePigGame.NUM_ROWS;
		while (_g1 < _g) {
			int row = _g1++;
			[self.tiles objectAtIndex:row] = [[NSMutableArray alloc] init];
			{
				int _g3 = 0; int _g2 = PiratePigGame.NUM_COLUMNS;
				while (_g3 < _g2) {
					int column = _g3++;
					[[self.tiles objectAtIndex:row] objectAtIndex:column] = nil;
				}
			}
		}
	}
	self.Background = [[UIView alloc] init];
	self.Logo = [[[UIImageView alloc] init] initWithImage:[UIImage imageNamed:(NSMutableString*)@"logo.png"]];
	self.Score = [[UILabel alloc] init];
	self.Score.frame = CGRectMake (0,0,100,50);
	self.Score.textColor = [UIColor yellowColor];
	self.Score.backgroundColor = [UIColor clearColor];
	self.Score.textAlignment =  NSTextAlignmentLeft;
	self.Score.font = [UIFont boldSystemFontOfSize:30];
	self.TileContainer = [[UIView alloc] init];
}
- (void) newGame{
	self.currentScore = 0;
	self.Score.text = (NSMutableString*)@"0";
	{
		int _g1 = 0; int _g = PiratePigGame.NUM_ROWS;
		while (_g1 < _g) {
			int row = _g1++;
			{
				int _g3 = 0; int _g2 = PiratePigGame.NUM_COLUMNS;
				while (_g3 < _g2) {
					int column = _g3++;
					[self removeTile:row column:column animate:NO];
				}
			}
		}
	}
	{
		int _g1 = 0; int _g = PiratePigGame.NUM_ROWS;
		while (_g1 < _g) {
			int row = _g1++;
			{
				int _g3 = 0; int _g2 = PiratePigGame.NUM_COLUMNS;
				while (_g3 < _g2) {
					int column = _g3++;
					[self addTile:row column:column animate:NO];
				}
			}
		}
	}
}
- (void) removeTile:(int)row column:(int)column animate:(BOOL)animate{
	// Simulated optional arguments
	if (animate == nil) animate = YES;
	
	
	Tile *tile = [[self.tiles objectAtIndex:row] objectAtIndex:column];
	if (tile != nil) {
		[tile remove:animate];
		[self.usedTiles push:tile];
	}
	[[self.tiles objectAtIndex:row] objectAtIndex:column] = nil;
}
- (void) resize:(int)newWidth newHeight:(int)newHeight{
	float maxWidth = newWidth * 0.90;
	float maxHeight = newHeight * 0.86;
	self.currentScale = 1;
	float currentWidth = self.frame.size.width;
	float currentHeight = self.frame.size.height;
	if (currentWidth > maxWidth || currentHeight > maxHeight) {
		float maxScaleX = maxWidth / currentWidth;
		float maxScaleY = maxHeight / currentHeight;
		if (maxScaleX < maxScaleY) self.currentScale = maxScaleX;
		else self.currentScale = maxScaleY;
	}
	CGRect rect = self.frame;
	rect.origin.x = newWidth / 2 - currentWidth * self.currentScale / 2;
	self.frame = rect;
}
- (void) swapTile:(Tile*)tile targetRow:(int)targetRow targetColumn:(int)targetColumn{
	if (targetColumn >= 0 && targetColumn < PiratePigGame.NUM_COLUMNS && targetRow >= 0 && targetRow < PiratePigGame.NUM_ROWS) {
		
		Tile *targetTile = [[self.tiles objectAtIndex:targetRow] objectAtIndex:targetColumn];
		if (targetTile != nil && !targetTile.moving) {
			[[self.tiles objectAtIndex:targetRow] objectAtIndex:targetColumn] = tile;
			[[self.tiles objectAtIndex:tile.row] objectAtIndex:tile.column] = targetTile;
			if ([self findMatches:YES accumulateScore:NO].length > 0 || [self findMatches:NO accumulateScore:NO].length > 0) {
				targetTile.row = tile.row;
				targetTile.column = tile.column;
				tile.row = targetRow;
				tile.column = targetColumn;
				CGPoint targetTilePosition = [self getPosition:targetTile row column:targetTile column];
				CGPoint tilePosition = [self getPosition:tile row column:tile column];
				[targetTile moveTo:0.3 targetX:targetTilePosition x targetY:targetTilePosition y];
				[tile moveTo:0.3 targetX:tilePosition x targetY:tilePosition y];
				self.needToCheckMatches = YES;
			}
			else {
				[[self.tiles objectAtIndex:targetRow] objectAtIndex:targetColumn] = targetTile;
				[[self.tiles objectAtIndex:tile.row] objectAtIndex:tile.column] = tile;
			}
		}
	}
}
- (void) touchesBegan:(NSSet*)touches withEvent:(UIEvent*)withEvent{
}
- (void) touchesMoved:(NSSet*)touches withEvent:(UIEvent*)withEvent{
}
- (void) touchesEnded:(NSSet*)touches withEvent:(UIEvent*)withEvent{
}
- (void) touchesCancelled:(NSSet*)touches withEvent:(UIEvent*)withEvent{
}
- (id) init{
	self = [super init];
	[super];
	[self initialize];
	[self construct];
	[self newGame];
	return self;
}

@end
